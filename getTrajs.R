#
# getTrajs.R 
#
# This script is distributed 'as is'. There's no guarantee that it will work with your data or for your application.
#
# J. Alfredo Freites
# jfreites@uci.edu
#
# 12/18/24:
# First wide distribution version based on getTrajs.batch.v3.R (v3.4)
#
# extracts trajectories with length greater than a given cutoff from JSON arrays generated by Flika (cf. Ly et al. for details https://doi.org/10.1101/2022.09.30.510193) 
#
# the JSON has two keys:
#   "tracks" is a list of track (row) indices (zero-based) indicating tracks present at a given frame 
#   "txy_pts" is a single 3-column matrix encompassing the whole experiment with colums  | frame number | x | y | organized according to the "tracks" list
# because the original list is zero-based, the trajectory with index i in "tracks" will be found in the rows of txy_pts indicated given by (tracks[[i]]+1)
#
# Package required: jsonlite
#          
# Run at the command line as
#
#         Rscript getTrajs.R cutoff jfilenamesList dataDir workDir filext 
# Input: 
#         cutoff: the minimum trajectory length to be extracted from the JSON array in consistent units (e.g. number of frames)
#         jfilenamesList: full path to a text file listing JSON filenames without extension from a single experimental session 
#         dataDir: path to the location of JSON files, it will be appended to each filename (defaults to the output of getwd())
#         workDir: where to dump the output (defaults to the output of getwd()) 
#         filext: a common file extension for all JSON filenames (defaults to "json")
#         if an entry in jfilenamesList is myfile, the file will be read as: paste0(dataDir,"/",myfile,'.',filext)
#
# Output:
#         One RDS file per JSON file containing a list of all the trajecories of length >=  cutoff 
#                     each list element is a 3-column matrix: | frame number | x | y |
#                     missing positions are encoded as NA
#                     the name of each list element is the name of the file + the track index in the JSON
#
#         if an entry in jfilenamesList is myfile, then corresponding output  will be paste0(workDir,"/",myfile,"-",cutoff,".rds")
#
# version 3.4 08/21/24
#


################################ user interface ################################################################

args<-commandArgs(trailingOnly = TRUE    )

if(length(args) < 2) {
    stop('at least two arguments')
    }

if(length(args) > 5) {
    stop('too many arguments')
    }

if(length(args) >= 3) {
    dataDir<-paste0(args[3],"/")
    } else {
    dataDir<-paste0(getwd(),"/")
    }

if(length(args) >= 4) {
    workDir<-paste0(args[4],"/")
    } else {
    workDir<-paste0(getwd(),"/")
    }

if(length(args) ==5) {
    filext<-args[5]
    } else {
    filext<-'json'
    }

#trajectory length cutoff
cutof<-as.numeric(args[1])

#list of json filenames (without extension)
jfilenames<-scan(args[2],what=character())



############################ end of user interface ###########################################################

library(jsonlite)

for(j in seq_along(jfilenames)) {
  theFileName<-paste0(dataDir,jfilenames[j],".",filext)
  if(file.exists(theFileName)){
    cat(paste("reading",jfilenames[j],"\n"))
    jfile<-fromJSON(theFileName)
    lens<-sapply(jfile$tracks,length)
    sel<-which(lens>=cutof)
    lsel<-length(sel)
    cat(paste("done reading",jfilenames[j],lsel,"extracted\n"))
    trajs<-vector(mode="list",length = lsel)
    for(i in seq_along(sel)) {
      mymat<-jfile$txy_pts[jfile$tracks[[sel[i]]]+1,]
      tmat<-matrix(nrow=mymat[nrow(mymat),1]-mymat[1,1]+1,ncol=2)
      tmat[mymat[,1]-mymat[1,1]+1,1:2]<-mymat[,2:3]
      trajs[[i]]<-tmat
      names(trajs)[i]<-paste0(jfilenames[j],"-",sel[i])
    }
    saveRDS(trajs,file = paste0(workDir,"/",jfilenames[j],"-",cutof,".rds"))
    cat(paste("processed",jfilenames[j],length(trajs),"saved\n"))
  } else {
    cat(paste(paste0(jfilenames[j],".",filext),"does not exists under",dataDir,"\n"))
  }
}
cat("Exiting normally\n")
